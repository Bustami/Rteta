---
title: "Predict matches"
author: "robert hickman"
date: "17/09/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  warning = FALSE,message = FALSE
)
```

```{r}
#libraries
library(tidyverse)
library(lubridate)
library(StatsBombR)
library(rlang)
```

```{r}
#get data
free_data <- data.frame(
  match_id = 15946,
  competition.competition_id = "who",
  season.season_id = "cares"
)
data <- StatsBombR::get.matchFree(free_data)

#get the length of each period
#should probably write a function to do this automatically
periods <- data %>%
  mutate(time = as.numeric(hms(timestamp))) %>%
  dplyr::group_by(period) %>%
  dplyr::summarise(period_length = max(time))

#get the shots in the data
shots <- data %>%
  #get the timestamp of events
  dplyr::mutate(prev_time = map_dbl(period, function(p) {
    if(p == 1) {
      return(0)
    } else {
      sum(periods$period_length[periods$period < p])
    }
  })
  ) %>%
  dplyr::mutate(time = as.numeric(hms(timestamp)) + prev_time,
                shot_team = factor(team.name)) %>%
  #filter shots
  dplyr::filter(type.name == "Shot") %>%
  #select relevant columns
  #not necessary per se
  dplyr::select(shot_team, shot_time = time, shot_xg = shot.statsbomb_xg)

#func to sim match
sim_match <- function(data, teams, times, xgs, max_phase_length = 5) {
  #get the vars
  both_teams <- levels(eval_tidy(enquo(teams), data))
  shot_teams <- eval_tidy(enquo(teams), data)
  shot_times <- eval_tidy(enquo(times), data)
  xgs <- eval_tidy(enquo(xgs), data)
  
  #filter out any non-xg coded events that might have snuck in
  if(any(is.na(xgs))) {
    shot_teams <- shot_teams[-is.na(xgs)]
    shot_times <- shot_times[-is.na(xgs)]
    xgs <- xgs[-is.na(xgs)]
  }

  #random numbers to sim
  random_numbers <- runif(xgs)
  #goals scored where xg > rand n
  goals <- which(xgs > random_numbers)
  
  #obviously a draw if no simmed goals
  if(length(goals) == 0) {
    return("draw")
  } else {
    
    #if any events happen within n seconds count as same play
    #cant score twice on same play
    too_soon <- which(shot_times[goals] - lag(shot_times[goals]) < max_phase_length)
    if(length(too_soon) > 0) {
      goals <- goals[-too_soon]
    }
    
    #get the goals per team
    team_goals <- shot_teams[goals]
    tabled_goals<- table(team_goals)

    #calc results
    if(tabled_goals[[1]] == tabled_goals[[2]]) {
      return("draw")
    } else if(tabled_goals[[1]] > tabled_goals[[2]]) {
      return(both_teams[[1]])
    } else {
      return(both_teams[[2]])
    }
  }
}

## Messy palette work ##

#ideally have a table of all colours you would need
team_cols <- data.frame(
  team = c("Barcelona", "Deportivo AlavÃ©s", "Real Madrid", "Arsenal"),
  colour = c("maroon", "dodgerblue", "grey80", "red")
)

teams <- levels(shots$shot_team)
cols <- team_cols$colour[team_cols$team %in% teams]

#define the colours on the plots
col_pal <- scale_colour_manual(values = cols, breaks = teams)
fill_pal <- scale_fill_manual(values = c(cols, "white"), breaks = c(teams, "draw"))
##


#rerun n times
times <- 1000
sims <- purrr::rerun(times, sim_match(shots, shot_team, shot_time, shot_xg))
#get the results of the sims
sim_results <- table(unlist(sims)) / times

sim_results
```
```{r}
#plot
plot_data <- as.data.frame(sim_results) %>%
  #reorder plotting levels
  #might want to play around with this to get the home team first always
  mutate(team = factor(Var1, levels = c(teams[1], "draw", teams[2])))

p <- ggplot(plot_data, aes(y = Freq, fill = team, x = 1)) +
  geom_bar(stat = "identity") +
  fill_pal +
  coord_flip() +
  labs(title = "simulated probabilities for match",
       x = "chance") +
  theme_minimal() +
  theme(legend.position = "bottom") +
  theme(axis.text.y = element_blank(),
        axis.title.y = element_blank())

p
```

```{r}
#messy step graph stuff
cumsum_xg <- shots %>%
  group_by(shot_team) %>%
  mutate(cumulative_xg = cumsum(shot_xg))

total_time <- sum(periods$period_length) 

end_xg <- cumsum_xg %>%
  summarise(cumulative_xg = max(cumulative_xg)) %>%
  mutate(shot_time = total_time)

start_xg <- cumsum_xg %>%
  summarise() %>%
  mutate(cumulative_xg = 0, shot_time = 0)

cumsum_xg <- bind_rows(cumsum_xg, end_xg, start_xg) %>%
  mutate(shot_mins = shot_time / 60)
  
p <- ggplot(cumsum_xg, aes(x = shot_mins, y = cumulative_xg, colour = shot_team)) +
  geom_step(size = 2) +
  col_pal +
  labs(
    title = paste0("MATCH INFO HERE", "shots and simulated games"),
    x = "minute",
    y = "cumulative xg for"
  ) +
  theme_minimal()

p
```

